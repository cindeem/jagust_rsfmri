import os, sys
import datetime
from glob import glob
import json

import numpy as np

import nibabel
import nipype.interfaces.spm as spm
from nipype.interfaces.base import CommandLine
from nipype.utils import filemanip

## deal with relative import for now
cwd = os.getcwd()
sys.path.insert(0, cwd)
import nipype_ext

########################

def get_files(dir, globstr):
    """
    uses glob to find dir/globstr
    returns sorted list; number of files
    """
    searchstr = os.path.join(dir, globstr)
    files = glob(searchstr)
    files.sort()
    return files, len(files)


def make_datestr():
    now = datetime.datetime.now()
    return now.strftime('%Y_%m_%d_%H_%S')


def get_slicetime(nslices):
    """
    If TOTAL # SLICES = EVEN, then the excitation order when interleaved
    is EVENS first, ODDS second.
    If TOTAL # SLICES = ODD, then the excitation order when interleaved is
    ODDS first, EVENS second.

    Returns:
    sliceorder: list
        list containing the order of slice acquisition used for slicetime correction

    """
    if np.mod(nslices,2) == 0:
        sliceorder = np.concatenate((np.arange(2,nslices+1,2),
                                     np.arange(1,nslices+1,2)))
    else:
        sliceorder = np.concatenate((np.arange(1,nslices+1,2),
                                     np.arange(2,nslices+1,2)))
    # cast to a list for use with interface
    return list(sliceorder)
        

def get_slicetime_vars(infiles, TR=None):
    """
    uses nibabel to get slicetime variables
    Returns: 
    dict: dict
        nsclies : number of slices
        TA : acquisition Time
        TR: repetition Time
        sliceorder : array with slice order to run slicetime correction
    """
    if hasattr('__iter__', infiles):
        img = nibabel.load(infiles[0])
    else:
        img = nibabel.load(infiles)
    hdr = img.get_header()
    if TR is None:
        raise RuntimeError('TR is not defined ')
    shape = img.get_shape()
    nslices = shape[2]
    TA = TR - TR/nslices
    sliceorder = get_slicetime(nslices)
    return dict(nslices=nslices,
                TA = TA,
                TR = TR,
                sliceorder = sliceorder)


def save_json(inobj, outfile):
    ''' save inobj to outfile using json'''
    try:
        json.dump(inobj, open(outfile,'w+'))
    except:
        raise IOError('Unable to save %s to %s (json)'%(inobj, outfile))


def load_json(infile):
    ''' use json to load objects in json file'''
    try:
        result = json.load(open(infile))
    except:
        raise IOError('Unable to load %s' %infile)
    return result


def zip_files(files):
    if not hasattr(files, '__iter__'):
        files = [files]
    for f in files:
        base, ext = os.path.splitext(f)
        if 'gz' in ext:
            # file already gzipped
            continue
        cmd = CommandLine('gzip %s' % f)
        cout = cmd.run()
        if not cout.runtime.returncode == 0:
            logging.error('Failed to zip %s'%(f))

def unzip_file(infile):
    """ looks for gz  at end of file,
    unzips and returns unzipped filename"""
    base, ext = os.path.splitext(infile)
    if not ext == '.gz':
        return infile
    else:
        if os.path.isfile(base):
            return base
        cmd = CommandLine('gunzip %s' % infile)
        cout = cmd.run()
        if not cout.runtime.returncode == 0:
            print 'Failed to unzip %s'%(infile)
            return None
        else:
            return base

def spm_realign_unwarp(infiles, matlab = 'matlab-spm8'):
    """ uses spm to run realign_unwarp
    Returns
    -------
    mean_img = File; mean generated by unwarp/realign

    realigned_files = Files; files unwarped and realigned

    parameters = File; file holding the trans rot params
    """
    
    startdir = os.getcwd()
    pth, _ = os.path.split(infiles[0])
    os.chdir(pth)    
    ru = nipype_ext.RealignUnwarp(matlab_cmd = matlab)
    ru.inputs.in_files = infiles
    ruout = ru.run()
    os.chdir(startdir)
    if not ruout.runtime.returncode == 0:
        print ruout.runtime.stderr
        return None, None, None
    return ruout.outputs.mean_image, ruout.outputs.realigned_files,\
           ruout.outputs.realignment_parameters


def make_mean(niftilist, prefix='mean_'):
    """given a list of nifti files
    generates a mean image"""
    if not hasattr(niftilist, '__iter__'):
        raise IOError('%s is not a list of valid nifti files, cannot make mean'%niftilist)
    n_images = len(niftilist)
    newfile = filemanip.fname_presuffix(niftilist[0], prefix=prefix)
    affine = nibabel.load(niftilist[0]).get_affine()
    shape =  nibabel.load(niftilist[0]).get_shape()
    newdat = np.zeros(shape)
    for item in niftilist:
        newdat += nibabel.load(item).get_data().copy()
    newdat = newdat / n_images
    newdat = np.nan_to_num(newdat)
    newimg = nibabel.Nifti1Image(newdat, affine)
    newimg.to_filename(newfile)
    return newfile


def spm_slicetime(infiles, matlab_cmd='matlab-spm8',stdict = None):
    """
    runs slice timing
    returns
    timecorrected_files
    """
    startdir = os.getcwd()
    pth, _ = os.path.split(infiles[0])
    os.chdir(pth)    
    if stdict == None:
        stdict = get_slicetime_vars(infiles)
    sliceorder = stdict['sliceorder']
    st = spm.SliceTiming(matlab_cmd = matlab_cmd)
    st.inputs.in_files = infiles
    st.inputs.ref_slice = np.round(stdict['nslices'] / 2.0).astype(int)
    st.inputs.slice_order = sliceorder
    st.inputs.time_acquisition = stdict['TA']
    st.inputs.time_repetition = stdict['TR']
    st.inputs.num_slices = stdict['nslices']
    out = st.run()
    os.chdir(startdir)
    if not out.runtime.returncode == 0:
        print out.runtime.stderr
        return None
    else:
        return out.outputs.timecorrected_files


def spm_coregister(moving, target, apply_to_files=None,
                   matlab_cmd='matlab-spm8'):
    """
    runs coregistration for moving to target
    """
    startdir = os.getcwd()
    pth, _ = os.path.split(moving)
    os.chdir(pth)    
    cr = spm.Coregister(matlab_cmd = matlab_cmd)
    cr.inputs.source = moving
    cr.inputs.target = target
    if apply_to_files is not None:
        cr.inputs.apply_to_files = apply_to_files
    out = cr.run()
    os.chdir(startdir)
    if not out.runtime.returncode == 0:
        print out.runtime.stderr
        return None, None
    else:
        return out.outputs.coregistered_source,\
               out.outputs.coregistered_files
